# Plan: YAML → PostgreSQL Player Persistence Migration

## Overview

Add a `PostgresPlayerRepository` implementation of the existing `PlayerRepository` interface, wired as a selectable backend alongside the current `YamlPlayerRepository`. Uses Flyway for schema migrations and HikariCP for connection pooling. Tests use H2 in PostgreSQL-compatibility mode (no Docker required).

---

## Phase 1: Dependencies & Config

### 1a. Add Gradle dependencies (`build.gradle.kts`)

```kotlin
// Connection pool
implementation("com.zaxxer:HikariCP:6.2.1")
// JDBC driver
implementation("org.postgresql:postgresql:42.7.5")
// Schema migration
implementation("org.flywaydb:flyway-core:11.3.0")
implementation("org.flywaydb:flyway-database-postgresql:11.3.0")

// Test: H2 in Postgres mode
testImplementation("com.h2database:h2:2.3.232")
```

### 1b. Add config types (`AppConfig.kt`)

Add a new `DatabaseConfig` data class and a `PersistenceBackend` enum:

```kotlin
enum class PersistenceBackend { YAML, POSTGRES }

data class DatabaseConfig(
    val jdbcUrl: String = "",
    val username: String = "",
    val password: String = "",
    val maxPoolSize: Int = 5,
    val minimumIdle: Int = 1,
)
```

Add `backend` field to `PersistenceConfig` and `database` field to `AppConfig`:

```kotlin
data class PersistenceConfig(
    val backend: PersistenceBackend = PersistenceBackend.YAML,
    val rootDir: String = "data/players",
    val worker: PersistenceWorkerConfig = PersistenceWorkerConfig(),
)

data class AppConfig(
    ...
    val database: DatabaseConfig = DatabaseConfig(),
    ...
)
```

Add validation in `validated()`:

```kotlin
if (persistence.backend == PersistenceBackend.POSTGRES) {
    require(database.jdbcUrl.isNotBlank()) { "ambonMUD.database.jdbcUrl required when backend=POSTGRES" }
    require(database.maxPoolSize > 0) { "ambonMUD.database.maxPoolSize must be > 0" }
}
```

### 1c. Add default config values (`application.yaml`)

```yaml
persistence:
  backend: YAML           # YAML or POSTGRES
  rootDir: data/players
  worker:
    enabled: true
    flushIntervalMs: 5000

database:
  jdbcUrl: ""
  username: ""
  password: ""
  maxPoolSize: 5
  minimumIdle: 1
```

---

## Phase 2: Flyway Migration & Schema

### 2a. Create migration file

Path: `src/main/resources/db/migration/V1__create_players_table.sql`

```sql
CREATE TABLE players (
    id         BIGINT       PRIMARY KEY,
    name       VARCHAR(16)  NOT NULL,
    room_id    VARCHAR(128) NOT NULL,
    constitution INT        NOT NULL DEFAULT 0,
    level      INT          NOT NULL DEFAULT 1,
    xp_total   BIGINT       NOT NULL DEFAULT 0,
    created_at_epoch_ms BIGINT NOT NULL,
    last_seen_epoch_ms  BIGINT NOT NULL,
    password_hash VARCHAR(72) NOT NULL DEFAULT '',
    ansi_enabled BOOLEAN     NOT NULL DEFAULT FALSE,
    is_staff   BOOLEAN      NOT NULL DEFAULT FALSE
);

CREATE UNIQUE INDEX idx_players_name_lower ON players (LOWER(name));
```

Notes:
- `BIGINT` primary key (not `BIGSERIAL`) — IDs are application-generated by the existing `nextId` logic or by a Postgres sequence added later.
- `LOWER(name)` unique index enforces case-insensitive uniqueness at the DB level.
- All column types are H2-compatible in `MODE=PostgreSQL`.

### 2b. Add ID sequence migration

Path: `src/main/resources/db/migration/V2__add_player_id_sequence.sql`

```sql
CREATE SEQUENCE player_id_seq START WITH 1 INCREMENT BY 1;
```

This replaces the `next_player_id.txt` file approach.

---

## Phase 3: PostgresPlayerRepository Implementation

### 3a. Create `PostgresPlayerRepository.kt`

Path: `src/main/kotlin/dev/ambon/persistence/PostgresPlayerRepository.kt`

Implements `PlayerRepository` using plain JDBC via HikariCP `DataSource`:

```kotlin
class PostgresPlayerRepository(
    private val dataSource: DataSource,
    private val metrics: GameMetrics = GameMetrics.noop(),
) : PlayerRepository {

    override suspend fun findByName(name: String): PlayerRecord? =
        withContext(Dispatchers.IO) {
            dataSource.connection.use { conn ->
                conn.prepareStatement("SELECT * FROM players WHERE LOWER(name) = LOWER(?)").use { stmt ->
                    stmt.setString(1, name.trim())
                    stmt.executeQuery().use { rs ->
                        if (rs.next()) rs.toPlayerRecord() else null
                    }
                }
            }
        }

    override suspend fun findById(id: PlayerId): PlayerRecord? =
        withContext(Dispatchers.IO) { /* SELECT * FROM players WHERE id = ? */ }

    override suspend fun create(...): PlayerRecord =
        withContext(Dispatchers.IO) {
            // SELECT nextval('player_id_seq')
            // INSERT INTO players (...)
            // Return PlayerRecord
        }

    override suspend fun save(record: PlayerRecord) =
        withContext(Dispatchers.IO) {
            // UPDATE players SET ... WHERE id = ?
            // (upsert via INSERT ... ON CONFLICT (id) DO UPDATE for safety)
        }
}
```

Key design decisions:
- **Plain JDBC** — no ORM. The schema is one table; JDBC keeps it simple and dependency-light.
- **`withContext(Dispatchers.IO)`** — same pattern as `YamlPlayerRepository`, keeps engine non-blocking.
- **Parameterized queries** — prevents SQL injection.
- **Metrics** — reuses existing `playerRepoLoadTimer` / `playerRepoSaveTimer` / `onPlayerSave()` / `onPlayerSaveFailure()`.
- **UPSERT on save** — `INSERT ... ON CONFLICT (id) DO UPDATE` so saves are idempotent (matches YAML behavior where save overwrites the file).

### 3b. Create `DatabaseManager.kt`

Path: `src/main/kotlin/dev/ambon/persistence/DatabaseManager.kt`

Encapsulates HikariCP pool creation and Flyway migration:

```kotlin
class DatabaseManager(private val config: DatabaseConfig) {
    private val hikariDataSource: HikariDataSource

    init {
        val hikariConfig = HikariConfig().apply {
            jdbcUrl = config.jdbcUrl
            username = config.username
            password = config.password
            maximumPoolSize = config.maxPoolSize
            minimumIdle = config.minimumIdle
        }
        hikariDataSource = HikariDataSource(hikariConfig)
    }

    val dataSource: DataSource get() = hikariDataSource

    fun migrate() {
        Flyway.configure()
            .dataSource(hikariDataSource)
            .load()
            .migrate()
    }

    fun close() {
        hikariDataSource.close()
    }
}
```

---

## Phase 4: Wiring in MudServer

### 4a. Update `MudServer.kt`

Replace the fixed `yamlRepo` initialization with backend selection:

```kotlin
private val databaseManager: DatabaseManager? =
    if (config.persistence.backend == PersistenceBackend.POSTGRES) {
        DatabaseManager(config.database).also { it.migrate() }
    } else null

private val baseRepo: PlayerRepository =
    when (config.persistence.backend) {
        PersistenceBackend.YAML -> YamlPlayerRepository(
            rootDir = Paths.get(config.persistence.rootDir),
            metrics = gameMetrics,
        )
        PersistenceBackend.POSTGRES -> PostgresPlayerRepository(
            dataSource = databaseManager!!.dataSource,
            metrics = gameMetrics,
        )
    }

// Redis cache wraps whichever backend is selected
private val redisRepo: RedisCachingPlayerRepository? =
    if (redisManager != null) {
        RedisCachingPlayerRepository(delegate = baseRepo, ...)
    } else null

private val l2Repo: PlayerRepository = redisRepo ?: baseRepo

// Write coalescing wraps whatever L2 is
private val coalescingRepo: WriteCoalescingPlayerRepository? = ...
private val playerRepo = coalescingRepo ?: l2Repo
```

Add `databaseManager?.close()` in `stop()`.

The full decorator chain `WriteCoalescing → RedisCache → Postgres/Yaml` is preserved unchanged.

---

## Phase 5: Tests

### 5a. `PostgresPlayerRepositoryTest.kt`

Path: `src/test/kotlin/dev/ambon/persistence/PostgresPlayerRepositoryTest.kt`

Uses H2 in PostgreSQL-compatibility mode. Mirrors the existing `YamlPlayerRepositoryTest` structure:

```kotlin
class PostgresPlayerRepositoryTest {
    companion object {
        private lateinit var dataSource: HikariDataSource

        @BeforeAll @JvmStatic
        fun setup() {
            val config = HikariConfig().apply {
                jdbcUrl = "jdbc:h2:mem:test;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE"
                username = "sa"
                password = ""
            }
            dataSource = HikariDataSource(config)
            Flyway.configure().dataSource(dataSource).load().migrate()
        }

        @AfterAll @JvmStatic
        fun teardown() { dataSource.close() }
    }

    @BeforeEach
    fun reset() {
        dataSource.connection.use { it.createStatement().execute("DELETE FROM players; ALTER SEQUENCE player_id_seq RESTART WITH 1") }
    }

    @Test fun `create then findById and findByName`() = runTest { ... }
    @Test fun `save persists changes`() = runTest { ... }
    @Test fun `create enforces unique name case-insensitive`() = runTest { ... }
    @Test fun `findByName returns null for unknown`() = runTest { ... }
    @Test fun `findById returns null for unknown`() = runTest { ... }
}
```

Tests cover:
1. Create + findById + findByName round-trip
2. Save persists all fields
3. Case-insensitive name uniqueness (throws `PlayerPersistenceException`)
4. Null returns for missing players
5. Flyway migrations apply cleanly on H2

### 5b. Existing tests remain unchanged

- `InMemoryPlayerRepository` unit tests — untouched
- `WriteCoalescingPlayerRepositoryTest` — untouched (wraps any `PlayerRepository`)
- `RedisCachingPlayerRepositoryTest` — untouched
- `YamlPlayerRepositoryTest` — untouched

---

## Phase 6: Lint & Verify

1. `./gradlew ktlintCheck` — ensure new code passes linting
2. `./gradlew test` — all existing + new tests pass

---

## Files Changed (Summary)

| File | Change |
|------|--------|
| `build.gradle.kts` | Add HikariCP, PostgreSQL driver, Flyway, H2 test deps |
| `src/main/kotlin/dev/ambon/config/AppConfig.kt` | Add `PersistenceBackend` enum, `DatabaseConfig`, validation |
| `src/main/resources/application.yaml` | Add `database` section, `backend` field |
| `src/main/resources/db/migration/V1__create_players_table.sql` | New: schema migration |
| `src/main/resources/db/migration/V2__add_player_id_sequence.sql` | New: ID sequence |
| `src/main/kotlin/dev/ambon/persistence/DatabaseManager.kt` | New: HikariCP + Flyway wrapper |
| `src/main/kotlin/dev/ambon/persistence/PostgresPlayerRepository.kt` | New: Postgres `PlayerRepository` impl |
| `src/main/kotlin/dev/ambon/MudServer.kt` | Backend selection wiring |
| `src/test/kotlin/dev/ambon/persistence/PostgresPlayerRepositoryTest.kt` | New: H2-backed tests |

## Out of Scope (Future Work)

- Data migration CLI tool (YAML → Postgres import)
- Inventory/items persistence
- World state persistence
- Connection pool metrics integration with Micrometer
